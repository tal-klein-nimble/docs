---
title: "Network Capture"
description: "Capture internal API calls and dynamic data without parsing HTML"
---

Network Capture intercepts internal API calls made during webpage loading, giving you direct access to structured data in JSON format instead of parsing HTML.

Common uses:

- **Dynamic content**: Capture lazy-loaded data and real-time updates.
- **API access**: Interact directly with backend APIs bypassing UI rendering.
- **Performance**: Reduce overhead by accessing machine-readable responses.
- **Accuracy**: Get reliable data directly from API endpoints.

<Note>
  Network Capture requires page rendering to be enabled (`render: true`). For XHR/AJAX calls that don't need rendering, use the `is_xhr` parameter instead.
</Note>

# Supported parameters

- `network_capture` - Network capture uses filters to target specific requests. You can combine multiple filters in a single request.

| Parameter                         | Type    | Description                                                                 |
| --------------------------------- | ------- | --------------------------------------------------------------------------- |
| `method`                          | String  | HTTP method filter (GET, POST, PUT, etc). Default: `Any`                    |
| `url.type`                        | Enum    | URL matching type: `exact` or `contains`. Default: `exact`                  |
| `url.value`                       | String  | The URL or URL portion to match                                             |
| `resource_type`                   | Array   | Filter by resource type: `xhr`, `fetch`, `stylesheet`, `script`, `document` |
| `validation`                      | Boolean | Enable content validation on responses. Default: `false`                    |
| `wait_for_requests_count`         | Integer | Minimum number of requests to capture. Default: `0`                         |
| `wait_for_requests_count_timeout` | Integer | Max wait time (seconds) for request count. Default: `10`                    |

# Usage

## Filter by exact URL match

Capture a specific API endpoint by matching the complete URL.

<CodeGroup>

```python Python
from nimble import Nimble

nimble = Nimble(api_key="YOUR-API-KEY")

result = nimble.extract(
    url="https://www.example.com",
    render=True,
    network_capture=[
        {
            "method": "GET",
            "url": {
                "type": "exact",
                "value": "https://www.example.com/api/data"
            }
        }
    ]
)

print(result)
```


```node Node.js
import { Nimble } from "@nimbleway/sdk";

const nimble = new Nimble({ apiKey: "YOUR-API-KEY" });

const result = await nimble.extract({
  url: "https://www.example.com",
  render: true,
  network_capture: [
    {
      method: "GET",
      url: {
        type: "exact",
        value: "https://www.example.com/api/data"
      }
    }
  ]
});

console.log(result);
```


```bash cURL
curl -X POST 'https://api.webit.live/api/v1/realtime/web' \
--header 'Authorization: Bearer <YOUR-API-KEY>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "url": "https://www.example.com",
    "render": true,
    "network_capture": [
        {
            "method": "GET",
            "url": {
                "type": "exact",
                "value": "https://www.example.com/api/data"
            }
        }
    ]
}'
```

</CodeGroup>

## Filter by URL pattern

Use `contains` to capture requests with URLs matching a pattern. This is useful for capturing file types (like `.css` or `.js`), requests with dynamic URL components, or when you don't know the exact URL.

<CodeGroup>

```python Python
from nimble import Nimble

nimble = Nimble(api_key="YOUR-API-KEY")

result = nimble.extract(
    url="https://www.example.com",
    render=True,
    network_capture=[
        {
            "url": {
                "type": "contains",
                "value": "/graphql"
            }
        }
    ]
)

print(result)
```


```node Node.js
import { Nimble } from "@nimbleway/sdk";

const nimble = new Nimble({ apiKey: "YOUR-API-KEY" });

const result = await nimble.extract({
  url:"https://www.example.com",
  render: true,
  network_capture: [
    {
      url: {
        type: "contains",
        value: "/api/"
      }
    }
  ]
});

console.log(result);
```


```bash cURL
curl -X POST 'https://api.webit.live/api/v1/realtime/web' \
--header 'Authorization: Bearer <YOUR-API-KEY>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "url": "https://www.example.com",
    "render": true,
    "network_capture": [
        {
            "url": {
                "type": "contains",
                "value": "/api/"
            }
        }
    ]
}'
```

</CodeGroup>

## Filter by resource type

Capture specific types of resources like XHR, Fetch, or Script requests.

<CodeGroup>

```python Python
from nimble import Nimble

nimble = Nimble(api_key="YOUR-API-KEY")

result = nimble.extract(
    url="https://www.example.com",
    render=True,
    network_capture=[
        {
            "method": "GET",
            "resource_type": ["xhr", "fetch"]
        }
    ]
)

print(result)
```


```node Node.js
import { Nimble } from "@nimbleway/sdk";

const nimble = new Nimble({ apiKey: "YOUR-API-KEY" });

const result = await nimble.extract({
  url:"https://www.example.com",
  render: true,
  network_capture: [
    {
      method: "GET",
      resource_type: ["xhr", "fetch"]
    }
  ]
});

console.log(result);
```


```bash cURL
curl -X POST 'https://api.webit.live/api/v1/realtime/web' \
--header 'Authorization: Bearer <YOUR-API-KEY>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "url": "https://www.example.com",
    "render": true,
    "network_capture": [
        {
            "method": "GET",
            "resource_type": ["xhr", "fetch"]
        }
    ]
}'
```

</CodeGroup>

## Multiple filters

Combine multiple filters to capture different request types in one call.

<CodeGroup>

```python Python
from nimble import Nimble

nimble = Nimble(api_key="YOUR-API-KEY")

result = nimble.extract(
    url="https://www.example.com",
    render=True,
    network_capture=[
        {
            "method": "GET",
            "url": {
                "type": "exact",
                "value": "https://www.example.com/api/resource"
            }
        },
        {
            "url": {
                "type": "contains",
                "value": ".css"
            }
        }
    ]
)

print(result)
```


```node Node.js
import { Nimble } from "@nimbleway/sdk";

const nimble = new Nimble({ apiKey: "YOUR-API-KEY" });

const result = await nimble.extract({
  url:"https://www.example.com",
  render: true,
  network_capture: [
    {
      method: "GET",
      url: {
        type: "exact",
        value: "https://www.example.com/api/resource"
      }
    },
    {
      url: {
        type: "contains",
        value: ".css"
      }
    }
  ]
});

console.log(result);
```


```bash cURL
curl -X POST 'https://api.webit.live/api/v1/realtime/web' \
--header 'Authorization: Bearer <YOUR-API-KEY>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "url": "https://www.example.com",
    "render": true,
    "network_capture": [
        {
            "method": "GET",
            "url": {
                "type": "exact",
                "value": "https://www.example.com/api/resource"
            }
        },
        {
            "url": {
                "type": "contains",
                "value": ".css"
            }
        }
    ]
}'
```

</CodeGroup>

## Wait for requests

Use `wait_for_requests_count` to ensure you capture a minimum number of network requests. The request duration will be extended until the count is reached or the timeout expires.

<CodeGroup>

```python Python
from nimble import Nimble

nimble = Nimble(api_key="YOUR-API-KEY")

result = nimble.extract(
    url="https://www.example.com",
    render=True,
    network_capture=[
        {
            "method": "GET",
            "resource_type": ["xhr", "script"],
            "wait_for_requests_count": 3,
            "wait_for_requests_count_timeout": 5
        }
    ]
)

print(result)
```


```node Node.js
import { Nimble } from "@nimbleway/sdk";

const nimble = new Nimble({ apiKey: "YOUR-API-KEY" });

const result = await nimble.extract({
  url:"https://www.example.com",
  render: true,
  network_capture: [
    {
      method: "GET",
      resource_type: ["xhr", "script"],
      wait_for_requests_count: 3,
      wait_for_requests_count_timeout: 5
    }
  ]
});

console.log(result);
```


```bash cURL
curl -X POST 'https://api.webit.live/api/v1/realtime/web' \
--header 'Authorization: Bearer <YOUR-API-KEY>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "url": "https://www.example.com",
    "render": true,
    "network_capture": [
        {
            "method": "GET",
            "resource_type": ["xhr", "script"],
            "wait_for_requests_count": 3,
            "wait_for_requests_count_timeout": 5
        }
    ]
}'
```

</CodeGroup>

<Note>
  This configuration will wait up to 5 seconds to capture at least 3 network requests matching the filter criteria.
</Note>

# XHR without rendering

For direct API endpoints that don't require page rendering, use `is_xhr` for better performance.

<CodeGroup>

```python Python
from nimble import Nimble

nimble = Nimble(api_key="YOUR-API-KEY")

result = nimble.extract(
    url="https://api.example.com/endpoint",
    is_xhr=True,
)

print(result)
```


```node Node.js
import { Nimble } from "@nimbleway/sdk";

const nimble = new Nimble({ apiKey: "YOUR-API-KEY" });

const result = await nimble.extract({
  url:"https://api.example.com/endpoint", 
  is_xhr: true,
});

console.log(result);
```


```bash cURL
curl -X POST 'https://api.webit.live/api/v1/realtime/web' \
--header 'Authorization: Bearer <YOUR-API-KEY>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "url": "https://api.example.com/endpoint",
    "is_xhr": true
}'
```

</CodeGroup>

<Note>
  `is_xhr` only works when `render` is `false`. It sends XHR-specific headers and targets the API URL directly.
</Note>